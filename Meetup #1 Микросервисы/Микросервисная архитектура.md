
# Слайд 1:

Микросервисная архитектура – одна из самых полезных архитектур в индустрии программного обеспечения. При правильном подходе она может помочь в создании лучших программных приложений.

# Слайд 2: 

Микросервисная и монолитная архитектуры представляют собой два различных способа организации программного кода, каждый из которых имеет свои уникальные особенности и области применения.
Монолитная архитектура — это традиционный подход к разработке программного обеспечения, при котором все компоненты приложения объединены в единое целое.

# Слайд 3:
### Преимущества монолитной архитектуры:
1. Простота развертывания: Все приложение развертывается как единое целое.
2. Легкость отладки: Проблемы легче обнаружить и исправить благодаря единой базе кода.
3. Высокая производительность: Отсутствие межсервисного взаимодействия может повысить производительность.

### Недостатки монолитной архитектуры:
1. Сложности в масштабировании: При необходимости масштабировать приложение приходится масштабировать все приложение целиком, даже если нагрузка увеличивается только на отдельные компоненты.
2. Трудности в внесении изменений: Изменения в одном компоненте могут повлиять на другие, что может привести к ошибкам и замедлить процесс разработки.
3. Технологические ограничения: Все компоненты приложения должны использовать одни и те же технологии.
4. Сложности с внедрением новых технологий: Внедрение новых технологий может быть затруднено из-за необходимости модифицировать большую часть кодовой базы.

# Слайд 4:
В микросервисной архитектуре слабо связанные сервисы взаимодействуют друг с другом для выполнения задач, относящихся к их бизнес-возможностям. Как правило, эти сервисы меньше, чем сервисы монолитной архитектуры. По сравнению с монолитом в микросервисах у вас есть несколько единиц развертывания. Каждый сервис развертывается самостоятельно.

# Слайд 5:
### Достоинства микросервисной архитектуры:
1. Масштабируемость: Каждый микросервис можно масштабировать независимо, что позволяет эффективно распределять ресурсы и справляться с пиковыми нагрузками.
2. Технологическая независимость: Каждый микросервис может использовать подходящую технологию, что дает гибкость в выборе инструментов и языков программирования.
3. Независимое развертывание: Микросервисы можно развертывать независимо, что ускоряет процесс разработки и развертывания.
4. Модульность: Каждый микросервис представляет собой отдельный модуль, что упрощает понимание и сопровождение кода.
5. Устойчивость к отказам: Отказ одного микросервиса не приводит к остановке всего приложения.
6. Легкость внедрения изменений: Изменения можно вносить в отдельные микросервисы без влияния на другие части системы.
7. Возможность повторного использования: Микросервисы могут быть повторно использованы в других приложениях.

### Недостатки микросервисной архитектуры:
1. Сложность: Микросервисная архитектура требует более сложной инфраструктуры и управления, чем монолитная.
2. Распределенные системы: Взаимодействие между микросервисами требует решения проблем, связанных с распределенными системами.
3. Увеличение числа компонентов: Большое количество микросервисов может усложнить общее представление о системе и увеличить время разработки.
4. Тестирование: Тестирование микросервисов требует больше усилий, так как необходимо тестировать как каждый сервис в отдельности, так и их взаимодействие.
5. Сложность развертывания: Развертывание и управление большим количеством микросервисов требует более сложных инструментов и процессов.

# Слайд 6:
Рассмотрим несколько основных паттернов, разделив их на условные группы в зависимости от решаемой задачи.

### Паттерны декомпозиции на микросервисы
Этот блок шаблонов предлагает решения для декомпозиции, то есть разделения приложений на микросервисы.

#### Шаблон «Разбиение по бизнес-возможностям» (Decompose By Business Capability)
Один из наиболее известных способов разбиения на микросервисы — это определение бизнес-возможностей приложения и создание по одному микросервису на каждую из них. Бизнес-возможности представляют собой функции, которые будут доступны пользователям при работе с приложением.

#### Шаблон «Разбиение по поддоменам» (Decompose By Subdomain)
Он основан на концепциях предметно-ориентированного проектирования (Domain-Driven Design, DDD). DDD разбивает всю модель предметной области (домен) на поддомены. У каждого поддомена своя модель данных, область действия которой принято называть ограниченным контекстом (Bounded Context). Каждый микросервис будет разрабатываться внутри этого ограниченного контекста. Основная задача при использовании DDD-подхода — подобрать поддомены и границы между ними так, чтобы они были максимально независимы друг от друга.

Если вернуться, к примеру с интернет-магазином, то все, что связано с заказами, можно рассматривать в рамках поддомена «Заказы» (Orders Subdomain) и именно внутри этого поддомена создавать микросервис по управлению заказами (Orders Service). Таким образом, можно сократить число микросервисов по сравнению с декомпозицией на основе бизнес-возможностей.

# Слайд 7:
### Паттерны рефакторинга для перехода на микросервисы
Эта группа шаблонов предназначена для организации взаимодействия с Legacy-приложениями и/или их постепенного перевода на микросервисную архитектуру.

#### Шаблон «Душитель» (Strangler)
Поэтому и был разработан паттерн Strangler, названный по аналогии с лианой, которая постепенно душит обвиваемое ею дерево.  
Этот шаблон означает миграцию монолитного приложения на микросервисную архитектуру путем постепенного переноса существующих функций в микросервисы. Настраивается маршрутизация запросов между устаревшим монолитом и микросервисами. Когда очередная функциональность переносится из монолита в микросервисы, фасад перехватывает клиентский запрос и направляет его к микросервисам. Новые функции при этом реализуются исключительно в микросервисах, минуя монолит. После переноса всех функций монолитное приложение полностью выводится из эксплуатации.

#### Шаблон «Уровень защиты от повреждений» (Anti-Corruption Layer)
Модернизация старых приложений подразумевает постепенный переход на микросервисы. Однако, не всегда возможно полностью заменить устаревшие компоненты. Паттерн Anti-Corruption Layer (ACL) решает эту проблему, создавая защитный слой между новыми и старыми системами. ACL выступает в роли переводчика, преобразуя данные и запросы в формат, понятный для каждой из систем. Это позволяет новым микросервисам взаимодействовать со старыми компонентами, не нарушая их целостность и не адаптируя их под новые стандарты.

# Слайд 8: Паттерны управления данными в микросервисной архитектуре

Этот блок шаблонов описывает возможные варианты взаимодействия микросервисов с базами данных.

### Шаблон "База данных на сервис"
Подход в микросервисной архитектуре, где каждый микросервис имеет свою собственную базу данных. Данные, относящиеся к конкретному сервису, хранятся изолированно от данных других сервисов.

### Шаблон «API-композиция» (API Composition)
После применения паттерна "База данных на сервис" данные можно получить из нескольких сервисов через отдельное API. Это API вызывает необходимые сервисы и объединяет их результаты в памяти. Паттерн часто используется с другим шаблоном — API Gateway.

> **Недостатки**: Может приводить к неэффективному объединению больших данных в памяти.

### Шаблон «Разделение команд и запросов» (CQRS)
CQRS отделяет изменение данных (Command) от их чтения (Query).

- **Простая форма**: Отдельные модели ORM для чтения и записи, но общее хранилище данных.
- **Расширенная форма**: Отдельные хранилища данных для записи и чтения с асинхронной синхронизацией между ними.

Расширенный CQRS часто используется вместе с паттерном Event Sourcing.

# Слайд 9: Шаблоны событий и транзакций

### Шаблон «Поиск событий» (Event Sourcing)
Хранение истории изменений в виде событий вместо текущего состояния данных. Для получения актуального состояния проигрываются все события с начала.

### Шаблон «Сага» (Saga)
Модуль управления распределенными транзакциями в микросервисах. Разделяет транзакцию на локальные операции и координирует их через обмен событиями. Если транзакция неудачна, запускается компенсирующая цепочка.

# Слайд 10: Паттерны коммуникации микросервисов

### Шаблон «API-шлюз» (API Gateway)
Позволяет клиентам взаимодействовать с несколькими микросервисами через единый вход. Включает:

- **Gateway Routing** — Перенаправление запросов клиента.
- **Gateway Aggregation** — Агрегация ответов от нескольких сервисов.
- **Gateway Offloading** — Сквозные задачи, такие как аутентификация, SSL.

### Шаблон «Бэкенды для фронтендов» (Backends for Frontends, BFF)
Множественные шлюзы для каждого типа клиента (Web, Mobile, Desktop), обеспечивающие независимое взаимодействие с микросервисами.

# Слайд 11: Паттерны построения пользовательского интерфейса

### Шаблон «Сборка пользовательского интерфейса на стороне клиента» (Client-Side UI Composition)
Разметка HTML создается и обновляется в браузере. Каждый фрагмент интерфейса получает данные от разных микросервисов.

### Шаблон «Сборка фрагментов страниц на стороне сервера» (Server-Side Page Fragment Composition)
Сборка фрагментов UI происходит на сервере, что ускоряет загрузку страницы.

# Слайд 12: Паттерны обнаружения сервисов

### Шаблон «Обнаружение сервисов на стороне клиента» (Client-Side Service Discovery)
Клиенты напрямую взаимодействуют с реестром сервисов для получения информации о доступных экземплярах сервисов.

### Шаблон «Обнаружение сервисов на стороне сервера» (Server-Side Service Discovery)
Маршрутизация и балансировка запросов осуществляется инфраструктурой развертывания через реестр сервисов.

# Слайд 13: Паттерны развертывания микросервисов

### Шаблон «Экземпляр сервиса на хост» (Service Instance Per Host)
Каждый экземпляр микросервиса развертывается на отдельном виртуальном сервере или контейнере, обеспечивая изоляцию.

### Шаблон «Сине-зеленое развертывание» (Blue-Green Deployment)
Обновления сервисов осуществляются через параллельные среды, переключая трафик между активной и новой версиями после успешного развертывания.

# Слайд 14: Паттерны повышения отказоустойчивости

### Шаблон «Автоматический выключатель» (Circuit Breaker)
Отслеживает неудачные запросы и блокирует дальнейшие попытки, предотвращая каскадные сбои.

### Шаблон «Переборка» (Bulkhead)
Изолирует ресурсы между компонентами системы, предотвращая влияние одного сбоя на другие.

# Слайд 15: Паттерны мониторинга микросервисов

### Шаблон «Агрегация логов» (Log Aggregation)
Централизованная система для сбора логов со всех микросервисов, что упрощает их анализ и мониторинг.

### Шаблон «Распределенная трассировка» (Distributed Tracing)
Присваивание каждому запросу уникального идентификатора (TraceId), который передается между сервисами для отслеживания полного пути запроса.

### Шаблон «Проверки здоровья» (Health Check)
Специальная конечная точка для проверки состояния сервиса. Если сервис неисправен, он исключается из ротации.

# Слайд 16: Прочие паттерны проектирования микросервисов

### Шаблон «Посредник» («Посол», Ambassador)
Унификация доступа к общим сервисам (мониторинг, безопасность) через прокси-сервис, что упрощает интеграцию и модернизацию.

### Шаблон «Коляска» («Прицеп», Sidecar)
Изоляция вспомогательных сервисов в отдельный контейнер или процесс рядом с основным приложением.

### Шаблон «Тестирование контрактов, ориентированных на потребителя» (Consumer-Driven Contract Testing)
Каждый потребитель сервиса пишет свои тесты для проверки данных, что улучшает независимость и выявление ошибок.

### Шаблон «Внешняя конфигурация» (External Configuration)
Конфигурация приложения хранится во внешнем хранилище для повышения безопасности и упрощения управления.
